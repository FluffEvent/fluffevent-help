import fs from 'node:fs'
import path from 'node:path'

import type { SidebarEntry } from '@astrojs/starlight/utils/routing/types'
import type { StarlightUserConfig } from '@astrojs/starlight/types'

const ROOT = path.resolve('./src/content/docs')

async function loadConfig(filePath: string): Promise<NonNullable<StarlightUserConfig['sidebar']>>
{
	if (fs.existsSync(filePath))
	{
		const config = await import(filePath)
		return config.default
	}

	return []
}

type SidebarConfigItem = NonNullable<StarlightUserConfig['sidebar']>[number]
type SidebarConfigItemBadge = Extract<SidebarConfigItem, { badge?: unknown }>['badge']

type SidebarEntryBadge = SidebarEntry['badge']

function formatBadge(badge: SidebarConfigItemBadge): SidebarEntryBadge
{
	if (badge === undefined)
	{
		return undefined
	}

	if (typeof badge === 'string')
	{
		return {
			variant: 'default',
			text: badge,
			class: undefined,
		}
	}

	return {
		variant: badge.variant ?? 'default',
		text: badge.text as string, // FIXME
		class: badge.class,
	}
}

function formatSidebarItem(item: SidebarConfigItem): SidebarEntry
{
	if (typeof item === 'string' || 'slug' in item)
	{
		// String item: <SidebarLinkItemSchema>
		// or Internal link item: <InternalSidebarLinkItemSchema>

		// TODO: Handle `translations` property
		const entry: SidebarEntry = typeof item !== 'string'
			? {
				type: 'link',
				label: item.label ?? item.slug, // FIXME
				href: item.slug,
				isCurrent: false,
				badge: formatBadge(item.badge),
				attrs: item.attrs ?? {},
			}
			: {
				type: 'link',
				label: item,
				href: item,
				isCurrent: false,
				badge: undefined,
				attrs: {},
			}

		// TODO: Load slug and information from the content collection

		return entry
	}

	if ('link' in item)
	{
		// External link item
		// <SidebarLinkItemSchema>
		// TODO: Handle `translations` property
		return {
			type: 'link',
			label: item.label,
			href: item.link,
			isCurrent: false,
			badge: formatBadge(item.badge),
			attrs: item.attrs ?? {},
		}
	}

	if ('autogenerate' in item)
	{
		// Autogenerating group item
		// <AutoSidebarGroupSchema>
		return {
			type: 'group',
			label: item.label,
			collapsed: item.autogenerate.collapsed ?? false,
			badge: formatBadge(item.badge),
			entries: [], // FIXME: Should be populated with autogenerated entries
		}
	}

	if ('items' in item)
	{
		// Manual group item
		// <ManualSidebarGroupSchema>
		return {
			type: 'group',
			label: item.label,
			collapsed: item.collapsed ?? false,
			badge: formatBadge(item.badge),
			entries: item.items.map(formatSidebarItem), // Recursively format items
		}
	}

	throw new Error(`Unsupported sidebar config item: ${JSON.stringify(item)}`)
}

export async function getSidebarConfig(slugPath: string): Promise<SidebarEntry[]>
{
	const segments = slugPath.split('/').filter(Boolean)
	const pathsToCheck = []

	// Build paths from base to leaf
	for (let i = 0; i <= segments.length; i++)
	{
		const dir = path.join(ROOT, ...segments.slice(0, i))
		pathsToCheck.push(path.join(dir, 'sidebar.config.ts'))
	}

	// Load and merge sidebar configs
	const configs = (await Promise.all(pathsToCheck.map(loadConfig))).flat()
	// or do deep merge if needed

	return configs.map((entry): SidebarEntry => formatSidebarItem(entry))
}
