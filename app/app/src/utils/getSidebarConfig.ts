import fs from 'node:fs'
import path from 'node:path'

import { getEntry } from 'astro:content'
import { getRelativeLocaleUrl } from 'astro:i18n'
import type { SidebarEntry } from '@astrojs/starlight/utils/routing/types'
import type { StarlightUserConfig } from '@astrojs/starlight/types'

const ROOT = path.resolve('./src/content/docs')

async function loadConfig(filePath: string): Promise<NonNullable<StarlightUserConfig['sidebar']>>
{
	if (fs.existsSync(filePath))
	{
		const config = await import(filePath)
		return config.default
	}

	return []
}

type SidebarConfigItem = NonNullable<StarlightUserConfig['sidebar']>[number]
type SidebarConfigItemBadge = Extract<SidebarConfigItem, { badge?: unknown }>['badge']

type SidebarEntryBadge = SidebarEntry['badge']

function formatBadge(badge: SidebarConfigItemBadge): SidebarEntryBadge
{
	if (badge === undefined)
	{
		return undefined
	}

	if (typeof badge === 'string')
	{
		return {
			variant: 'default',
			text: badge,
			class: undefined,
		}
	}

	return {
		variant: badge.variant ?? 'default',
		text: badge.text as string, // FIXME
		class: badge.class,
	}
}

async function formatSidebarItem(item: SidebarConfigItem, userUrl: URL, userLocale: string): Promise<SidebarEntry>
{
	if (typeof item === 'string' || 'slug' in item)
	{
		// String item: <SidebarLinkItemSchema>
		// or Internal link item: <InternalSidebarLinkItemSchema>

		// Load collection entry by slug
		const slug = typeof item === 'string' ? item : item.slug
		const collectionEntry = await getEntry('docs', slug)

		if (collectionEntry)
		{
			// collectionEntry.data should contain:
			// - title: string
			// - editUrl: boolean
			// - head: Array
			// - template: string
			// - sidebar: { hidden: boolean, attrs: Record }
			// - pagefind: boolean
			// - draft: boolean

			const label = collectionEntry.data?.title as string | undefined
			const href = getRelativeLocaleUrl(userLocale, slug)

			const normalizePath = (p: string) => p === '/' ? '/' : p.replace(/\/+$/, '')
			const isCurrent = normalizePath(userUrl.pathname) === normalizePath(href)

			// TODO: Handle `translations` property
			return typeof item !== 'string'
				? {
					type: 'link',
					label: label || item.label || slug,
					href: href,
					isCurrent: isCurrent,
					badge: formatBadge(item.badge),
					attrs: item.attrs ?? {},
				}
				: {
					type: 'link',
					label: label || slug,
					href: href,
					isCurrent: isCurrent,
					badge: undefined,
					attrs: {},
				}
		}

		throw new Error(`Collection entry not found for slug: ${slug}`)
	}

	if ('link' in item)
	{
		// External link item
		// <SidebarLinkItemSchema>
		// TODO: Handle `translations` property
		return {
			type: 'link',
			label: item.label,
			href: item.link,
			isCurrent: false,
			badge: formatBadge(item.badge),
			attrs: item.attrs ?? {},
		}
	}

	if ('autogenerate' in item)
	{
		// Autogenerating group item
		// <AutoSidebarGroupSchema>
		return {
			type: 'group',
			label: item.label,
			collapsed: item.autogenerate.collapsed ?? false,
			badge: formatBadge(item.badge),
			entries: [], // FIXME: Should be populated with autogenerated entries
		}
	}

	if ('items' in item)
	{
		// Manual group item
		// <ManualSidebarGroupSchema>
		return {
			type: 'group',
			label: item.label,
			collapsed: item.collapsed ?? false,
			badge: formatBadge(item.badge),
			entries: await Promise.all(item.items.map(item => formatSidebarItem(item, userUrl, userLocale))), // Recursively format items
		}
	}

	throw new Error(`Unsupported sidebar config item: ${JSON.stringify(item)}`)
}

export async function getSidebarConfig(slugPath: string, userUrl: URL, userLocale: string): Promise<SidebarEntry[]>
{
	const segments = slugPath.split('/').filter(Boolean)
	const pathsToCheck = []

	// Build paths from base to leaf
	for (let i = 0; i <= segments.length; i++)
	{
		const dir = path.join(ROOT, ...segments.slice(0, i))
		pathsToCheck.push(path.join(dir, 'sidebar.config.ts'))
	}

	// Load and merge sidebar configs
	const configs = (await Promise.all(pathsToCheck.map(loadConfig))).flat()
	// or do deep merge if needed

	return Promise.all(configs.map(item => formatSidebarItem(item, userUrl, userLocale)))
}
